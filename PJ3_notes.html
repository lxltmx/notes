<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    //chapter 5
        //Array.prototype.sort(fn);
        /*原理:没有fn，则逐项调用toString()，按转化的字符串的诸个字符的Unicode位点进行排序；
        fn(a, b) 小于 0,a前b后，
        fn(a, b) 等于 0,不变，
        fn(a, b) 大于 0,反之。
        function compare(a, b) {
          if (a < b ) {
            return -1;
          }
          if (a > b ) {
            return 1;
          }
          return 0;
        }*/
        /*var a= [2,1,3];
        console.log(a.sort((a,b) => a - b)); //[1,2,3]
        console.log(a.sort((a,b) => b - a)); //[3,2,1]*/

        /*var data2 = [
            {name:'lx2',age:17},
            {name:'lx',age:19},
            {name:'lx3',age:18}
        ];
        data2.sort(function(a,b) {
            var v1 = a.age;
            var v2 = b.age;
            if(v1<v2){
                return -1;
            }
            if(v1>v2){
                return 1;
            }
            return 0;
        })
        console.log(data2);
        data2.sort(function(a,b) {
            var v1 = a.name.toUpperCase();
            var v2 = b.name.toUpperCase();
            if(v1<v2){
                return -1;
            }
            if(v1>v2){
                return 1;
            }
            return 0;
        })
        console.log(data2);*/
        //此处存疑，为何两次都按照后一次的属性排列

    //chapter 6
        //属性(数据属性/访问器属性)
            //定义属性内部特性(描述符, [[attribute]] )方法
            /*数据属性
            Object.defineProperty(obj,property,{
                writable: true,
                enumberabel: true,
                configurable: true,
                value: true
            })*/
            /*访问器属性
            Object.defineProperty(obj,property,{
                enumberabel: true,
                configurable: true,
                get:function(){},
                set:function(){}
            })
            var book = {
                _year: 2018,
                edition: 1
            };
            Object.defineProperty(book,"year",{
                get:function() {
                    return this._year;
                },
                set: function(v) {
                    if (v>2018){
                        this._year = v;
                    }
                }
            });
            book.year = 2019;  //一定要通过set？此处为何不直接修改book,_year = 2019?(_是种约定，只能通过对象方法访问)
            alert(book.edition);*/

            //注意:调用defineProperty,如不指定，enumberabel,writable,configurable都默认为true
            //configurable一旦定义成false，则不可再改回。
            /*var person = {};
            Object.defineProperty(person,'age',{
                configurable: false,
                value: 18
            });
            alert(person.age);
            delete person.age;
            alert(person.age);

            Object.defineProperty(person,'age',{
                configurable: true,
            });
            alert(person.age);  //error: Cannot redefine property: age*/

        //创建自定义对象方法
            //1.创建一个Object实例
            /*var person = new Object();
            person.name = 'lx';
            person.age = 18;
            person.sayName = function() {
                alert(this.name);
            };*/

            //2.对象字面量
            /*var person = {
                name: 'lx',
                age: 18,
                sayName: function() {
                    alert(this.name);
                }
            }*/

            //缺点:使用同一个接口创建很多对象，代码重复。

            //3.工厂模式
            /*function createPerson(name,age) {
                var person = new Object();
                person.name = name;
                person.age = age;
                person.sayName = function() {
                    alert(this.name);
                }
                return person;
            }
            var person1 = createPerson('lx1','18');
            var person2 = createPerson('lx2','80');*/
            //缺点:未解决对象识别问题(怎样知道对象的类型)

            //4.构造函数模式
            /*function Person(name,age) {
                this.name = name,
                this.age = age,
                this.sayName = function() {
                    alert(this.name);
                }
            }
            var person1 = new Person('lx1','18');
            var person2 = new Person('lx2','80');*/
            //与工厂模式区别：没有显示创建对象；直接将属性和方法赋给this对象；没有return。
            //new 过程：创建实例对象；this指向实例对象；执行构造函数(给新对象添属性)；返回实例对象。
            //缺点：每个方法都要在实例上重新创建一遍 alert(person1.sayName == person2.sayName)//false;

            //5.原型模式
            /*function Person() {}
            Person.prototype.name = 'lx';
            Person.prototype.age = '18';
            Person.prototype.friends = ['a','b'];
            Person.prototype.sayName = function() {
                alert(this.name);
            };
            var person1 = new Person();
            var person2 = new Person();
            alert(person1.sayName == person2.sayName)//true;*/
            //缺点：不能向构造函数传参；原型中引用类型的属性也会被共享（修改person1.friends,person2.friends一起变）
                //原型模式字面量语法
                /*function Person() {}
                Person.prototype = {
                    name : 'lx',
                    age : 18,
                    sayName: function() {
                        alert(this.name);
                    }
                }*/
                //缺点：完全重写了默认的原型对象(开辟了新内存空间),constructor属性不再指向构造函数Person
                //修改：
                /*Person.prototype = {
                    constructor: Person,
                    ...
                }*/

            //6.组合使用构造函数和原型模式
            /*function Person(name,age) {
                this.name = name;
                this.age = age;
                this.friends = ['a','b'];
            }
            Person.prototype = {
                constructor: Person,
                sayName: function() {
                    alert(this.name);
                }
            };
            var person1 = new Person('lx',18);
            var person2 = new Person('lx2',80);
            person1.friends.push('c');
            console.log(person1,person2);*/

        //原型动态性
            //可以随时为原型添加属性和方法，并立刻在实例中生效
            /*function Person() {}
            var friend = new Person();
            Person.prototype.sayHi = function() {
                alert("hi");
            }
            friend.sayHi(); //"hi"*/
            //但如果用对象字面量语法重写原型，实例对象内部属性[[Proptype]]指针指向的是构造函数实例化时的原型对象
            /*function Person() {}
            var friend = new Person();
            Person.prototype = {
                sayHi: function() {
                    alert("hi");
                }
            }
            friend.sayHi(); //"friend.sayHi is not a function"*/
        
        //寄生构造函数模式
        //需要一个具有额外方法的数组，不能直接修改数组构造函数
        /*function SpecialArray() {
            var v = new Array(); 
            v.push.apply(v,arguments);
            v.toPipedString = function() {
                return v.join('|');
            };
            return v;
        }
        var larr = new SpecialArray('a','b','c');
        
        console.log(larr);*/
        //larr.toPipedString();
        //此处存疑，和直接larr = SpecialArray('a','b','c')有什么区别？

        //继承
        //原理：子类型的原型等于父类型的实例(重写子类型的原型对象)，子类型的原型中则会有内部属性指向父类型的原型
        /*function Father() {
            this.name = 'lx';
            this.sex = 'male';
        }
        Father.prototype.sayName = function() {
            alert(this.name);
        }
        function Son() {
            this.name = 'my';
            this.age = 66;
        }

        Son.prototype = new Father();
        Son.prototype.growUp = function(){
            this.age++;
        }

        var son1 = new Son();
        console.log(son1,Son.prototype);*/
        //此时Son类型的原型被重写，console.log(son1.constructor,'~~~~~~~~~~~~~~~~~~~~',son1.__proto__.constructor,'~~~~~~~~~~~~~~~~~~~~',Son.prototype.constructor,'~~~~~~~~~~~~~~~~~~~~',new Father().__proto__.constructor,'~~~~~~~~~~~~~~~~~~~~',Father.prototype.constructor,'~~~~~~~~~~~~~~~~~~~~',Father);
        
    </script>
</body>
</html>